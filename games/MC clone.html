<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Simple Minecraft Clone</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: monospace; }
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            background-color: transparent;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            mix-blend-mode: difference;
            z-index: 10;
        }
        #instructions {
            position: absolute;
            top: 10px; left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="instructions">
        <b>Click to Start</b><br>
        WASD: Move<br>
        SPACE: Jump<br>
        Click: Mine Block<br>
        Right Click (or Ctrl+Click): Place Block
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Configuration ---
        const BLOCK_SIZE = 1; // Size of each cube
        const WORLD_SIZE = 20; // Initial floor size (20x20)
        
        // --- Globals ---
        let camera, scene, renderer, controls;
        let raycaster;
        const objects = []; // Stores all blocks for collision/raycasting
        
        // Movement flags
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;

        // Physics variables
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Materials
        let grassMaterial, dirtMaterial;

        init();
        animate();

        function init() {
            // 1. Setup Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 70);

            // 2. Setup Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2; // Start player slightly above ground

            // 3. Setup Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // 4. Generate Textures (Procedural to avoid external assets)
            grassMaterial = createBlockMaterial('#5C9E66', '#3B6E44'); // Top green, side dirt
            dirtMaterial = createBlockMaterial('#6B4226', '#6B4226');  // All brown

            // 5. Build Initial World
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            for (let x = -WORLD_SIZE/2; x < WORLD_SIZE/2; x++) {
                for (let z = -WORLD_SIZE/2; z < WORLD_SIZE/2; z++) {
                    const block = new THREE.Mesh(geometry, grassMaterial);
                    block.position.set(x * BLOCK_SIZE, 0, z * BLOCK_SIZE);
                    scene.add(block);
                    objects.push(block);
                }
            }

            // 6. Setup Controls
            controls = new PointerLockControls(camera, document.body);
            
            const blocker = document.getElementById('instructions');
            
            document.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                blocker.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'block';
            });

            scene.add(controls.getObject());

            // Key Listeners
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = true; break;
                    case 'Space': 
                        if (canJump === true) velocity.y += 12; // Jump force
                        canJump = false;
                        break;
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp':
                    case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft':
                    case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown':
                    case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight':
                    case 'KeyD': moveRight = false; break;
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // 7. Raycasting (Interaction)
            raycaster = new THREE.Raycaster();
            document.addEventListener('mousedown', onMouseClick);

            // 8. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        // --- Helper: Procedural Textures ---
        function createBlockMaterial(colorTop, colorSide) {
            // Simple function to create a texture for the block
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorSide;
            ctx.fillRect(0,0,64,64);
            // Add some noise/texture
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            for(let i=0; i<20; i++) ctx.fillRect(Math.random()*64, Math.random()*64, 8, 8);
            
            const textureSide = new THREE.CanvasTexture(canvas);
            textureSide.magFilter = THREE.NearestFilter; // Pixelated look

            // Create top texture slightly different (if needed)
            const canvasTop = document.createElement('canvas');
            canvasTop.width = 64; canvasTop.height = 64;
            const ctxTop = canvasTop.getContext('2d');
            ctxTop.fillStyle = colorTop;
            ctxTop.fillRect(0,0,64,64);
            ctxTop.fillStyle = "rgba(255,255,255,0.1)";
            for(let i=0; i<20; i++) ctxTop.fillRect(Math.random()*64, Math.random()*64, 8, 8);
            
            const textureTop = new THREE.CanvasTexture(canvasTop);
            textureTop.magFilter = THREE.NearestFilter;

            // Material Array: Right, Left, Top, Bottom, Front, Back
            return [
                new THREE.MeshLambertMaterial({ map: textureSide }), // Right
                new THREE.MeshLambertMaterial({ map: textureSide }), // Left
                new THREE.MeshLambertMaterial({ map: textureTop }),  // Top
                new THREE.MeshLambertMaterial({ map: textureSide }), // Bottom
                new THREE.MeshLambertMaterial({ map: textureSide }), // Front
                new THREE.MeshLambertMaterial({ map: textureSide })  // Back
            ];
        }

        function onMouseClick(event) {
            if (!controls.isLocked) return;

            // Set raycaster from center of screen
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const intersects = raycaster.intersectObjects(objects, false);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                // Distinguish between left click (remove) and right click (add)
                // event.button === 0 is Left, 2 is Right. 
                // We also allow Ctrl+Click for Mac users or trackpads.
                
                if (event.button === 0 && !event.ctrlKey) {
                    // Mine block
                    scene.remove(intersect.object);
                    objects.splice(objects.indexOf(intersect.object), 1);
                } else {
                    // Place block
                    // Get the normal to know which side to place it on
                    const voxel = new THREE.Mesh(new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), dirtMaterial);
                    
                    // Copy position of the hit block
                    voxel.position.copy(intersect.object.position);
                    
                    // Add the normal vector to place it adjacent
                    voxel.position.add(intersect.face.normal);
                    
                    // Ensure we don't place a block inside the player
                    const playerPos = controls.getObject().position;
                    const dx = Math.abs(playerPos.x - voxel.position.x);
                    const dz = Math.abs(playerPos.z - voxel.position.z);
                    const dy = Math.abs(playerPos.y - voxel.position.y);
                    
                    // Simple collision check to prevent stuck player
                    if (dx < 0.8 && dz < 0.8 && dy < 1.8) {
                        return; // Too close to player
                    }

                    scene.add(voxel);
                    objects.push(voxel);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();

            if (controls.isLocked === true) {
                // Physics and Movement logic
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 3.0 * delta; // Gravity

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Ensure consistent speed in all directions

                if (moveForward || moveBackward) velocity.z -= direction.z * 100.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 100.0 * delta;

                // Move Player Side/Forward
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // Simple Floor Collision
                // (In a real engine, we'd check blocks below. Here we check Y height or raycast down)
                const playerPos = controls.getObject().position;
                
                // Very basic collision: Check if ray down hits a block
                raycaster.set(playerPos, new THREE.Vector3(0, -1, 0));
                const intersections = raycaster.intersectObjects(objects);
                const onObject = intersections.length > 0 && intersections[0].distance < 1.5;

                if (onObject) {
                    velocity.y = Math.max(0, velocity.y);
                    canJump = true;
                }

                // Apply Gravity Movement
                controls.getObject().position.y += (velocity.y * delta); 

                // Floor safety net (reset if fall off world)
                if (controls.getObject().position.y < -10) {
                    velocity.y = 0;
                    controls.getObject().position.set(0, 10, 0);
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>